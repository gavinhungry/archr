#!/usr/bin/env node

/**
 * archr - Search for and download Arch Linux packages
 * https://github.com/gavinhungry/archr
 */

(function() {
  'use strict';

  var pjson = require('../package.json');
  var archr = require('../lib/archr.js');

  var async    = require('async');
  var Download = require('download');
  var Q        = require('q');
  var sprintf  = require('sprintf');

  /**
   * Exit now
   *
   * @param {Number} [code] - exit code
   * @param {String} [msg] - exit message
   */
  var exit = function(code, msg) {
    code = code || 0;

    if (msg) {
      var output = (code === 0) ? 'log' : 'error';
      console[output](msg);
    }

    process.exit(code);
  };

  /**
   * Split repo and pkgname apart
   *
   * @param {String} pkgname - package name or repo/package
   * @return {Object} { repo, pkgname }
   */
  var split = function(pkgname) {
    var repo = null;

    var s = pkgname.split('/');
    if (s.length > 1) {
      repo = s[0]
      pkgname = s[1];
    }

    return {
      repo: repo,
      pkgname: pkgname
    };
  };

  /**
   * Print search results
   *
   * @param {String} query
   * @return {Promise}
   */
  var search = function(query) {
    var args = split(query);

    return archr.search(args.pkgname, args.repo, app.arch).then(function(results) {
      results.map(function(pkg) {
        var line = sprintf('%s/%s', pkg.repo, pkg.pkgname);

        if (!app.quiet) {
          line += sprintf(' %s-%s', pkg.pkgver, pkg.pkgrel);
        }

        return line;
      }).sort().forEach(function(line) {
        console.log(line);
      });
    }, function(err) {
      exit(1, 'Search error');
    });
  };

  /**
   * Download a file
   *
   * @param {String} uri - file URI
   * @return {Promise} to resolve to saved path, or reject with error
   */
  var download = function(uri) {
    var d = Q.defer();

    var dl = new Download({ mode: '0644' }).get(uri).dest(app.dir);

    console.log('Downloading', uri);
    dl.run(function(err, files, stream) {
      if (err) {
        console.error(sprintf('Error: %s %s', err.statusCode, err.statusMessage));
        return d.reject(err);
      }

      d.resolve(files[0].path);
    });

    return d.promise;
  };

  /**
   * Download multiple files
   *
   * @param {Array} uris - file URIs
   * @return {Promise} to resolve to saved paths
   */
  var downloads = function(uris) {
    var d = Q.defer();

    async.series(uris.map(function(uri) {
      return function(callback) {
        download(uri, app.dir).then(function(path) {
          callback(null, path);
        }, function(err) {
          callback(null, null);
        });
      };
    }), function(err, results) {
      var paths = results.filter(function(result) {
        return result !== null;
      });

      d.resolve(paths);
    });

    return d.promise;
  };

  var app = require('commander')
    .version(pjson.version)
    .option('-a, --arch <arch>', sprintf('system architecture [%s]', archr.defaults.arch))
    .option('-d, --dir <dir>', 'path to save downloads', process.cwd())
    .option('-q, --quiet', 'no version output');

  app.command('search <query>').action(search);

  app.command('download <pkg> [pkg...]').action(function(pkg, pkgs) {
    pkgs.unshift(pkg);
    var uris_p = pkgs.map(split).map(function(pkg) {
      return archr.download(pkg.pkgname, pkg.repo, app.arch);
    });

    Q.allSettled(uris_p).then(function(results) {
      var uris = results.filter(function(result) {
        return result.state === 'fulfilled';
      }).map(function(result) {
        return result.value;
      });

      return downloads(uris);
    });
  });

  if (process.argv.length <= 2) {
    app.help();
  }

  app.parse(process.argv);

})();
